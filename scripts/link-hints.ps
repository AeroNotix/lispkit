(in-package :lispkit.link-hints)

(defun qsa (context selector)
  "Alias of document.querySelectorAll"
  (chain context (query-selector-all selector)))

(defun remove-if-not (predicate sequence)
  "Small reimplementation of remove-if"
  (loop for el in sequence
       when (funcall predicate el)
       collect el))

(defun is-in-viewport (el)
  "Finds out if an element is in the viewport"
  (let ((rect (chain el (get-bounding-client-rect))))
    (and
     (>= (@ rect top) 0)
     (>= (@ rect left) 0)
     (<= (@ rect bottom) (or (@ window inner-height)
			     (@ document document-element client-height)))
     (<= (@ rect right) (or (@ window inner-width)
			    (@ document document-element client-width))))))

(defun find-links (window document)
  "Finds all the links within the viewport"
  (remove-if-not #'is-in-viewport (qsa document "a")))

(defun add-hints (links)
  "Adds hints on links"
  (let* ((links-length (length links))
	 (hints (generate-hints links-length)))
    (loop for i from 0 to links-length
	 collect (add-hint (elt links i) (elt hints i)))))

(defun generate-hints (length)
  "Generates hints that will appear on the links"
  nil)

(defun add-hint (link hint)
  "Adds a hint on a single link"
  (let ((hint-element (create-hint-element link hint)))
    (chain document (append-child hint-element))
    hint-element))

(defun create-hint-element (link hint)
  (let ((rect (chain link (get-bounding-client-rect)))
	(el (chain document (create-element "span"))))
    ;; @todo set position absolute and top/left values
    ;; for this, use `rect` and window.innerStuff... I guess
    (setf (@ el text-content) hint)
    el))

(defun add-hints-handler (window hints)
  "Adds a global handler to select to correct hint"
  (let ((remaining-hints))
    (lambda ())))

(defun run ()
  "Initializes the link hints"
  ;; add-hints-handler needs a closure
  ((add-hints-handler window (add-hints (find-links window document)))))
