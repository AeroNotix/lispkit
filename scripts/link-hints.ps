(in-package :lispkit.link-hints)

(defun qsa (context selector)
  "Alias of document.querySelectorAll"
  (chain context (query-selector-all selector)))

(defun floor (n)
  "Alias of Math.floor"
  (chain -math (floor n)))

(defun code-char (n)
  "Alias of String.fromCharCode"
  (chain -string (from-char-code n)))

(defun remove-if-not (predicate sequence)
  "Small reimplementation of remove-if"
  (loop for el in sequence
       when (funcall predicate el)
       collect el))

(defun is-in-viewport (el)
  "Finds out if an element is in the viewport"
  (let ((rect (chain el (get-bounding-client-rect))))
    (and
     (>= (@ rect top) 0)
     (>= (@ rect left) 0)
     (<= (@ rect bottom) (or (@ window inner-height)
			     (@ document document-element client-height)))
     (<= (@ rect right) (or (@ window inner-width)
			    (@ document document-element client-width))))))

(defun find-links (window document)
  "Finds all the links within the viewport"
  (remove-if-not #'is-in-viewport (qsa document "a")))

(defun add-hints (links)
  "Adds hints on links"
  (let* ((links-length (length links))
	 (hints (generate-hints links-length)))
    (loop for i from 0 to links-length
	 collect (add-hint (elt links i) (elt hints i)))))

(defun generate-hints (length)
  "Generates hints that will appear on the links"
  (generate-strings length (determine-chars-length length)))

(defun determine-chars-length (length)
  "Finds out how many chars long the hints must be"
  (let ((i 1))
    ;; 26 chars in alphabet
    (loop while (> length (expt 26 i))
	 do (incf i))
    i))

(defun generate-strings (length chars-length)
  "Generates strings of specified length"
  (let ((minimum (1+ (chain -math (pow 26 (- chars-length 1))))))
    (loop for i from minimum to (+ minimum length)
       collect (generate-string i))))

(defun generate-string (n)
  "Generates a string from a number"
  (if (>= n 0)
      (+ (generate-string (floor (- (/ n 26) 1)))
	 (code-char (+ 65
		       (rem n 26))))
      ""))

(defun add-hint (link hint)
  "Adds a hint on a single link"
  (let ((hint-element (create-hint-element link hint)))
    (chain document (append-child hint-element))
    hint-element))

(defun hint-determine-position (rect)
  "Determines the position of a hint according to the link"
  (create :top (@ rect top)
	  :left (- (@ rect left) 10)))

(defun create-hint-element (link hint)
  "Creates a DOM element to be used as a hint"
  (let* ((rect (chain link (get-bounding-client-rect)))
	 (position (hint-determine-position rect))
	 (el (chain document (create-element "span"))))
    (setf (@ el style position) "absolute")
    (setf (@ el style left) (+ (@ position left) "px"))
    (setf (@ el style top) (+ (@ position top) "px"))
    (setf (@ el text-content) hint)
    el))

(defun add-hints-handler (window hints)
  "Adds a global handler to select the correct hint"
  (let ((remaining-hints hints))
    (lambda ()
      (flet ((handler (e)
	       nil)
	     (remove-handler ()
	       (chain document (remove-event-listener "keypress" #'handler))
	       ;; Also remove itself
	       (chain document (remove-event-listener "click" #'remove-handler))
	       (chain document (remove-event-listener "scroll" #'remove-handler))))
	(chain document (add-event-listener "keypress" #'handler))
	(chain document (add-event-listener "click" #'remove-handler))
	(chain document (add-event-listener "scroll" #'remove-handler))))))

(defun run ()
  "Initializes the link hints"
  ;; add-hints-handler needs a closure
  ((add-hints-handler window (add-hints (find-links window document)))))
